<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.7.6
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.README.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'>
<h1 id="label-Candy">Candy</h1>

<p><strong>“Mongo like candy!”</strong> – <em>Blazing Saddles</em></p>

<p>Candy&#39;s goal is to provide the simplest possible object persistence for
the <a href="http://mongodb.org">MongoDB</a> database. By “simple” we mean
“nearly invisible.” Candy doesn&#39;t try to mirror ActiveRecord or
DataMapper. Instead, we play to MongoDB&#39;s unusual strengths – extremely
fast writes and a set of field-specific update operators – and do away with
the cumbersome, unnecessary methods of last-generation workflows.</p>

<p>Methods like <code>find</code>.</p>

<p>Or <code>save</code>.</p>

<h2 id="label-Overview">Overview</h2>

<p>When you mix the <strong>Candy::Piece</strong> module into a class, the
class gains a Mongo collection as an alter ego. Objects are saved to Mongo
the first time you set a property. Any property you set thereafter is sent
to Mongo <em>immediately</em> and <em>atomically.</em> You don&#39;t need
to declare the properties; we use <code>method_missing</code> to drive the
getting and setting of any field you want in any record. Or you can use the
hashlike <code>[]</code> and <code>[]=</code> operators if that&#39;s more
in your comfort zone.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Piece</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_me'>me</span> <span class='op'>=</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_last_name'>last_name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Eley</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'># New record created and saved to Mongo
</span><span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span>                   <span class='comment'># =&gt; ObjectId(4bb606f9609c8417cf00004b) or thereabouts
</span><span class='id identifier rubyid_me'>me</span><span class='lbracket'>[</span><span class='symbol'>:height</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='int'>67</span>        <span class='comment'># Or me.height = 67 -- either way, updates with a Mongo $set
</span></code></pre>

<h3 id="label-Embedded+Documents">Embedded Documents</h3>

<p>We got &#39;em. Candy pieces can contain each other recursively, to any
arbitrary depth. There&#39;s no need for complex
<code>has_and_belongs_to_many :through {:your =&gt;
&#39;mother&#39;}</code> type declarations. Just assign an object or a
bunch of objects to a field. Hashes and arrays become Candy-aware analogues
of themselves (<strong>CandyHash</strong> and <strong>CandyArray</strong>)
with live updating and the same recursive embedding. Non-Candy objects are
serialized into a flat hash structure that retains their class and instance
variables, so they can be rehydrated later.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_favorites'>favorites</span> <span class='op'>=</span> <span class='lbrace'>{</span> <span class='label'>composer:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Yoko Kanno</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
                 <span class='label'>seafood:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Maryland blue crabs</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
                 <span class='label'>scotch:</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Glenmorangie Port Wood Finish</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
                          <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Balvenie Single Barrel</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='rbrace'>}</span>
<span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_spouse'>spouse</span> <span class='op'>=</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_piece'>piece</span><span class='lparen'>(</span><span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Anna</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>eyes:</span> <span class='symbol'>:blue</span><span class='rparen'>)</span>
<span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_spouse'>spouse</span><span class='period'>.</span><span class='id identifier rubyid_eyes'>eyes</span>            <span class='comment'># =&gt; :blue
</span><span class='id identifier rubyid_me'>me</span><span class='period'>.</span><span class='id identifier rubyid_favorites'>favorites</span><span class='period'>.</span><span class='id identifier rubyid_scotch'>scotch</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span>    <span class='comment'># =&gt; &#39;Balvenie Single Barrel&#39;
</span></code></pre>

<h3 id="label-Retrieval">Retrieval</h3>

<p>Again, transparency is the key. The same <code>method_missing</code> tactic
applies to class methods to retrieve individual records:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_last_name'>last_name</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Smith</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>  <span class='comment'># Returns the first Smith
</span><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='lparen'>(</span><span class='int'>21</span><span class='rparen'>)</span>             <span class='comment'># Returns the first legal drinker (in the U.S.)
</span><span class='const'>Person</span><span class='lparen'>(</span><span class='int'>12345</span><span class='rparen'>)</span>              <span class='comment'># Returns the person with an _id of 12345
</span></code></pre>

<p>Take note of that last example. It&#39;s moderately deep magic, and we take
care not to stomp on any class-like methods you&#39;ve already defined. But
it&#39;s the simplest possible way to retrieve a record by ID.
<code>Person.first(&#39;_id&#39; =&gt; 12345)</code> works too, of course.</p>

<h3 id="label-Collections">Collections</h3>

<p>Some applications don&#39;t need to iterate through all records of a query;
you might just need the first record from a queue or something. When you do
need them, the anonymous “sort of like an array, except when it isn&#39;t”
encapsulation of collections in other ORMs is clunky and confusing. So
enumerable cursors live in their own <strong>Candy::Collection</strong>
module, which you explicitly mix into a class and then link back to the
<strong>Candy::Piece</strong> class:</p>

<pre class="code ruby"><code class="ruby">class People
  include Candy::Collection
  collects :person   # Declares the Mongo collection is &#39;Person&#39;
end                  # (and so is the Candy::Piece class)

People.last_name(&#39;Smith&#39;)                         # Returns an enumeration of all Smiths
People.age(19).sort(:birthdate, :down).limit(10)  # We can chain options
People(limit: 47, occupation: :ronin)             # Or People.all(params) or People.new(params)
People.each(|p| p.shout = &#39;Norm!&#39;)                # Where everybody knows your name...</code></pre>

<p>You can also, of course, just do <code>People.new()</code> with a bunch of
query conditions. You don&#39;t need two separate hashes for your fields
and your Mongo options; Candy knows which keys are MongoDB query options
and will automatically separate them for you. The collection module is
really just a thin wrapper around a <strong>Mongo::Cursor</strong> and
passes most of its behavior to the cursor – so you can do
<code>each</code>, <code>next</code>, et cetera.</p>

<p><strong>Q:</strong> <em>Why can&#39;t I just have Person automatically link
to People? I want my Raaaaails!</em></p>

<p><strong>A:</strong> Because including ActiveSupport as a dependency would
be nuts, whereas pasting in my own table of plural inflections would merely
double the code base. I&#39;m not against magic, obviously, but that&#39;s
expensive magic for little benefit. You&#39;ll just have to type those
three lines of code yourself.</p>

<h2 id="label-Prerequisites">Prerequisites</h2>
<ul><li>
<p><strong>Ruby 1.9.x</strong> The code uses the <a
href="http://snippets.dzone.com/posts/show/7891">new hash syntax</a>, UTF-8
encoding, and 1.9ish enumerable methods. No whining. If you&#39;re starting
a <em>new</em> project in mid-2010 or later and you&#39;re still using 1.8,
you&#39;re hurting us all. And kittens. You don&#39;t want to hurt kittens,
do you?</p>
</li><li>
<p><strong>MongoDB 1.4+</strong> You could probably get away with 1.2 for
<em>some</em> functionality, but the new array operators and <a
href="http://www.mongodb.org/display/DOCS/findandmodify+Command">findAndModify</a>
were too useful to pass up. It&#39;s a safe and easy upgrade, so if
you&#39;re not on the latest Mongo yet… Well, you&#39;re not hurting
kittens, but you&#39;re hurting <em>yourself.</em></p>
</li><li>
<p><strong>mongo gem 0.19+</strong> The Ruby gem seems to lag behind actual
Mongo development by quite a bit sometimes. 0.19.1 is the latest at the
time of this writing, and some commands (e.g. <code>findAndModify</code>)
have been implemented in Candy because the gem doesn&#39;t have methods for
them yet. We&#39;ll continue to streamline our code as the driver allows.</p>
</li></ul>

<h2 id="label-Installation">Installation</h2>

<p>Come on, you&#39;ve done this before:</p>

<pre class="code ruby"><code class="ruby">$ sudo gem install candy</code></pre>

<p>(Or leave off the <em>sudo</em> if you&#39;re smart enough to be using <a
href="http://rvm.beginrescueend.com/">RVM</a>.)</p>

<h2 id="label-Configuration">Configuration</h2>

<p>The simplest possible thing that works:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Zagnut</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Piece</span>
<span class='kw'>end</span>
</code></pre>

<p>That&#39;s it. Honest. Some Mongo plumbing is hooked in and instantiated
the first time the <code>.collection</code> attribute is accessed:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_connection'>connection</span> <span class='comment'># =&gt; Defaults to localhost port 27017
</span><span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_db'>db</span>         <span class='comment'># =&gt; Defaults to your username, or &#39;candy&#39; if unknown
</span><span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_collection'>collection</span> <span class='comment'># =&gt; Defaults to the class name (&#39;Zagnut&#39;)
</span></code></pre>

<p>You can override the DB or collection by providing name strings or
<strong>Mongo::DB</strong> and <strong>Mongo::Collection</strong> objects.
Or you can set certain module-level properties to make it easier for
multiple Candy classes in an application to use the same database:</p>
<ul><li>
<p><strong>Candy.host</strong></p>
</li><li>
<p><strong>Candy.port</strong></p>
</li><li>
<p><strong>Candy.connection</strong></p>
</li><li>
<p><strong>Candy.connection_options</strong> (A hash of options to the
Connection object)</p>
</li><li>
<p><strong>Candy.db</strong> (Can provide a string or a database object)</p>
</li></ul>

<p>All of the above is pretty general-purpose. If you want to use this
class-based Mongo functionality in your own projects, simply include
<code>Candy::Crunch</code> in your own classes.</p>

<h2 id="label-Using+It">Using It</h2>

<p>The trick here is to think of Candy objects like OpenStructs. Or if
that&#39;s too technical, imagine the objects as thin candy shells around a
chewy <code>method_missing</code> center:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Zagnut</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Piece</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_zag'>zag</span> <span class='op'>=</span> <span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>      <span class='comment'># A blank document enters the Zagnut collection
</span><span class='id identifier rubyid_zag'>zag</span><span class='period'>.</span><span class='id identifier rubyid_taste'>taste</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Chewy!</span><span class='tstring_end'>&quot;</span></span>  <span class='comment'># Properties are created and saved as they&#39;re used
</span><span class='id identifier rubyid_zag'>zag</span><span class='period'>.</span><span class='id identifier rubyid_calories'>calories</span> <span class='op'>=</span> <span class='int'>600</span>

<span class='id identifier rubyid_nut'>nut</span> <span class='op'>=</span> <span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_taste'>taste</span> <span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Chewy!</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>  <span class='comment'># Or Zagnut(taste: &#39;Chewy!&#39;)
</span><span class='id identifier rubyid_nut'>nut</span><span class='period'>.</span><span class='id identifier rubyid_calories'>calories</span>          <span class='comment'># =&gt; 600
</span>
<span class='id identifier rubyid_kingsize'>kingsize</span> <span class='op'>=</span> <span class='const'>Zagnut</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_kingsize'>kingsize</span><span class='period'>.</span><span class='id identifier rubyid_calories'>calories</span> <span class='op'>=</span> <span class='int'>900</span>  <span class='comment'># Or kingsize[:calories] = 900
</span><span class='id identifier rubyid_kingsize'>kingsize</span><span class='period'>.</span><span class='id identifier rubyid_ingredients'>ingredients</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cocoa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>peanut butter</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
<span class='id identifier rubyid_kingsize'>kingsize</span><span class='period'>.</span><span class='id identifier rubyid_ingredients'>ingredients</span> <span class='op'>&lt;&lt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>corn syrup</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
<span class='id identifier rubyid_kingsize'>kingsize</span><span class='period'>.</span><span class='id identifier rubyid_nutrition'>nutrition</span> <span class='op'>=</span> <span class='lbrace'>{</span> <span class='label'>sodium:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>115mg</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>protein:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3g</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_kingsize'>kingsize</span><span class='period'>.</span><span class='id identifier rubyid_nutrition'>nutrition</span><span class='period'>.</span><span class='id identifier rubyid_fat'>fat</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='label'>saturated:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>4g</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>total:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>9g</span><span class='tstring_end'>&#39;</span></span><span class='rbrace'>}</span>
<span class='id identifier rubyid_kingsize'>kingsize</span><span class='lbracket'>[</span><span class='symbol'>:nutrition</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:fat</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:saturated</span><span class='rbracket'>]</span>   <span class='comment'># =&gt; &#39;4g&#39;
</span>
<span class='kw'>class</span> <span class='const'>Zagnuts</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Collection</span>
  <span class='id identifier rubyid_collects'>collects</span> <span class='const'>Zagnut</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_bars'>bars</span> <span class='op'>=</span> <span class='const'>Zagnuts</span>      <span class='comment'># Or Zagnuts.all or Zagnuts.new
</span><span class='id identifier rubyid_bar'>bar</span><span class='period'>.</span><span class='id identifier rubyid_count'>count</span>           <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_sum'>sum</span> <span class='op'>=</span> <span class='const'>Zagnuts</span><span class='period'>.</span><span class='id identifier rubyid_inject'>inject</span> <span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_sum'>sum</span><span class='comma'>,</span><span class='id identifier rubyid_bar'>bar</span><span class='op'>|</span> <span class='id identifier rubyid_sum'>sum</span> <span class='op'>+</span> <span class='id identifier rubyid_bar'>bar</span><span class='period'>.</span><span class='id identifier rubyid_calories'>calories</span><span class='rbrace'>}</span>  <span class='comment'># =&gt; 1500
</span></code></pre>

<p>Note that writes are always live, but reads hold onto the retrieved
document and cache its values to avoid query delays. You can force a
requery at any time with the <code>refresh</code> method. (An expiration
feature wherein documents are requeried after a set time has elapsed is
being considered for the future.)</p>

<h2 id="label-Advanced+Classes">Advanced Classes</h2>

<p>Candy properties are fundamentally just entries in a hash, with some hooks
to the MongoDB <code>$set</code> updater when something changes. The
primary reason we&#39;ve implemented Candy as modules is so that you keep
control of your own classes&#39; behavior and inheritance. To have
properties that <em>don&#39;t</em> store to the Mongo collection, all you
have to do is define them explicitly:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Weight</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Piece</span>

  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbol'>:gravity</span>  <span class='comment'># This won&#39;t be stored in MongoDB
</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_kilograms'>kilograms</span>
    <span class='id identifier rubyid_pounds'>pounds</span> <span class='op'>*</span> <span class='float'>2.2046</span>  <span class='comment'># &#39;pounds&#39; is undeclared, so Candy retrieves it
</span>  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_kilograms='>kilograms=</span><span class='lparen'>(</span><span class='id identifier rubyid_val'>val</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_pounds'>pounds</span> <span class='op'>=</span> <span class='id identifier rubyid_val'>val</span><span class='op'>/</span><span class='float'>2.2046</span>  <span class='comment'># &#39;pounds=&#39; is undeclared; Candy stores it
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Embedded hashes are of type <strong>CandyHash</strong> unless you
explicitly assign an object that includes <strong>Candy::Piece</strong>.
(CandyHash itself is really just a Candy piece that doesn&#39;t store its
classname.) If you want truly quick-and-dirty persistence, you can even
just use a CandyHash as a standalone object and skip creating your own
classes:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_hash'>hash</span> <span class='op'>=</span> <span class='const'>CandyHash</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>foo:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='symbol'>:yoo</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='symbol'>:yar</span>   <span class='comment'># Persists to the &#39;candy&#39; collection by default
</span><span class='id identifier rubyid_hash'>hash</span><span class='period'>.</span><span class='id identifier rubyid_too'>too</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='symbol'>:tar</span><span class='comma'>,</span> <span class='symbol'>:car</span><span class='comma'>,</span> <span class='symbol'>:far</span><span class='rbracket'>]</span>

<span class='id identifier rubyid_hash2'>hash2</span> <span class='op'>=</span> <span class='const'>CandyHash</span><span class='lparen'>(</span><span class='id identifier rubyid_hash'>hash</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span>
<span class='id identifier rubyid_hash2'>hash2</span><span class='period'>.</span><span class='id identifier rubyid_foo'>foo</span>       <span class='comment'># =&gt; &#39;bar&#39;
</span><span class='id identifier rubyid_hash2'>hash2</span><span class='period'>.</span><span class='id identifier rubyid_yoo'>yoo</span>       <span class='comment'># =&gt; :yar
</span><span class='id identifier rubyid_hash2'>hash2</span><span class='lbracket'>[</span><span class='symbol'>:too</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span>  <span class='comment'># =&gt; :car
</span></code></pre>

<p>Embedded arrays are of type <strong>CandyArray</strong>. Unlike
CandyHashes, CandyArrays do <em>not</em> include
<strong>Candy::Piece</strong> and cannot operate as standalone objects.
They only make sense when embedded in a Candy piece. That&#39;s just the
way Mongo works.</p>

<h2 id="label-Good+Practices">Good Practices</h2>

<p><em>(I&#39;m not going to call them “Best” practices because you might
think of better ones than me.)</em></p>

<h3 id="label-Validations">Validations</h3>

<p>The long-term plan includes support for ActiveModel features as an optional
extension. In the meantime, one simple trick is to decorate your
properties:</p>

<p>class Person  include Candy::Piece</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_email='>email=</span><span class='lparen'>(</span><span class='id identifier rubyid_val'>val</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Invalid email address!</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_val'>val</span> <span class='op'>!~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$</span><span class='regexp_end'>/</span></span>
  <span class='kw'>super</span>
<span class='kw'>end</span>
</code></pre>

<p>end</p>

<p><em>Exceptions for validation failures?</em> Why yes. One consequence of a
doctrine of instant persistence is that <em>not</em> persisting connotes
something&#39;s wrong. I personally prefer rescues to deeply nested
&#39;else&#39; clauses to handle failures anyway. If you disagree, you
could implement the above in a kinder, gentler way:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_email='>email=</span><span class='lparen'>(</span><span class='id identifier rubyid_val'>val</span><span class='rparen'>)</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_val'>val</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$</span><span class='regexp_end'>/</span></span>
    <span class='kw'>super</span>
  <span class='kw'>else</span>
    <span class='lparen'>(</span><span class='ivar'>@errors</span> <span class='op'>||=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Invalid email address!</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>false</span>   <span class='comment'># (Or nil, but that gets confusing if you can actually assign nil.)
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>If that seems like a lot of work compared to
<code>validates_format_of</code> – well, you&#39;re right. As I said,
it&#39;s coming. In the meantime, just don&#39;t validate frivolously.
Leave minor tips and cleanups to the interface layer, and only refuse to
save in cases where allowing the value would break something.</p>

<h3 id="label-Named+Scopes">Named Scopes</h3>

<p>Dirt simple. Use a method in the collection class.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>People</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Collection</span>
  <span class='id identifier rubyid_collects'>collects</span> <span class='symbol'>:person</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_voters'>voters</span>
    <span class='id identifier rubyid_age'>age</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$gt</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>18</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_citizen'>citizen</span><span class='lparen'>(</span><span class='kw'>true</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h3 id="label-Required+Fields">Required Fields</h3>

<p>Instant document creation makes it problematic to wait to see if a
user&#39;s going to fill in a field. One tactic is to require those fields
in the constructor:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Candy</span><span class='op'>::</span><span class='const'>Piece</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_options'>options</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Last name is required!</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_options'>options</span><span class='lbracket'>[</span><span class='symbol'>:last_name</span><span class='rbracket'>]</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Email address is required!</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_options'>options</span><span class='lbracket'>[</span><span class='symbol'>:email</span><span class='rbracket'>]</span>
    <span class='kw'>super</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>last_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Eley</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>email:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sfeley@gmail.com</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'># This is valid
</span></code></pre>

<p>Or you can use the above scoping trick to make sure your application&#39;s
standard collections operate only on records that are “complete.” You could
even make it intrinsic to the class itself:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>ValidPeople</span> <span class='op'>&lt;</span> <span class='const'>People</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_options'>options</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_options'>options</span><span class='period'>.</span><span class='id identifier rubyid_merge!'>merge!</span><span class='lparen'>(</span><span class='label'>last_name:</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$exists</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span><span class='comma'>,</span> <span class='label'>email:</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$exists</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='kw'>super</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2 id="label-Philosophy">Philosophy</h2>

<p>Even relative to other ORMs, Candy&#39;s pretty opinionated. Here are some
of the opinions behind the design.</p>
<ul><li>
<p>Applications should be beautiful.</p>
</li><li>
<p>In a beautiful application, most of the code clearly and obviously furthers
primary activities. (Business needs, use cases, user stories, the critical
path, call it whatever you want.)</p>
</li><li>
<p>Data storage is not a primary activity. It&#39;s a supporting activity.
It&#39;s something you have to do so that the primary activities you do
today remain done tomorrow.</p>
</li><li>
<p>An application structure which reflects the constraints of supporting
activities more than the achievement of primary activities is not
beautiful.</p>
</li><li>
<p>Current Ruby ORMs go a long way towards eliminating the boilerplate cruft
found in other languages&#39; frameworks. But they don&#39;t go far
<em>enough.</em></p>
</li><li>
<p><code>Save</code> sucks. The &#39;write-now-commit-later&#39; pattern of
most ORMs creates brittleness and uncertainty. If I change the state of
something, <em>I want it changed.</em> My framework shouldn&#39;t hold its
breath waiting for me to say “Simon Says.”</p>
</li><li>
<p>Frameworks should be beautiful.</p>
</li><li>
<p>A beautiful framework is one whose fundamentals can be read and understood
by a journeyman developer with appropriate background knowledge in one
sitting.</p>
</li><li>
<p>Frameworks that are too large or complex to be beautiful can sometimes be
broken down into smaller frameworks that <em>are</em> beautiful.</p>
</li><li>
<p>Beautiful frameworks should be transparent and non-constraining. A
<em>truly</em> beautiful framework is one you have to squint to see.</p>
</li><li>
<p><em>Magic</em> (defined as “behavior whose workings are not immediately
apparent”) is fine in a framework. In a sense it&#39;s what frameworks
<em>are.</em> But magical behavior should be restrained, consistent,
clearly documented, and must not violate the Principle of Least Surprise.</p>
</li><li>
<p>Thomas Jefferson wrote that software frameworks should be subject to
revolution every couple of years. ("The tree of agility must be refreshed
from time to time with the blood of senior architects and project managers.
It is its natural manure.") I will be disappointed if Candy is not roundly
decried for being too complex, bloated, and intrusive by 2013 at the
latest.</p>
</li><li>
<p>There is a finite amount of seriousness allowed in any open source project.
A project that takes itself too seriously is using up its reserves, and is
less likely to be taken seriously by its user base.</p>
</li><li>
<p>A project that appeals to playfulness is more likely to be explored with
vigor, and if it withstands the exploration, creates <em>passion.</em></p>
</li><li>
<p>A README with this many bullet points in a single list should probably
stop.</p>
</li></ul>

<h2 id="label-Caveats-2C+Limitations-2C+and+To-Dos">Caveats, Limitations, and To-Dos</h2>

<p>This is very, very alpha software. I&#39;m using it in some non-trivial
projects right now, but it&#39;s far from bulletproof, and a lot of things
aren&#39;t implemented yet. In particular:</p>
<ul><li>
<p>The API is still in flux and subject to overhauling, undermining, or
carpetbombing at any time. Candy v0.2, for instance, has barely a wisp of
resemblance to Candy v0.1. (My apologies to the 155 of you who downloaded
0.1.)</p>
</li><li>
<p>CandyHashes and CandyArrays don&#39;t yet implement the full set of methods
you&#39;d expect from hashes and arrays. I mean to flesh them out to make
them more compatible. (You can help by creating issues to tell me what
methods you need most.)</p>
</li><li>
<p>Collections are not terribly robust nor well-tested yet. They
&#39;work&#39; in the sense that they pass a bunch of things to
<strong>Mongo::Cursor</strong>, but I personally consider the cursor
functionality to be a bit wonky. I&#39;d like to make enumerations more
repeatable and have the cursors more certain to be released after garbage
collection.</p>
</li><li>
<p>Currently every property assignment is a separate write to the database
(mostly using <strong>$set</strong>.) This is fine, but for cases where a
lot of properties are set at once we will eventually have transaction-like
behavior using blocks.</p>
</li><li>
<p>Many Mongo update operators, such as <strong>$pushAll</strong> and
<strong>$pop</strong> and <strong>$addToSet</strong>, are not implemented
yet or are not fully leveraged. (Saving a full document isn&#39;t
implemented either, but that&#39;s a deliberate feature.)</p>
</li><li>
<p>For high-concurrency use cases or for huge documents, more control of the
document caching is called for. I&#39;d like to have an option to declare
only certain fields to be retrieved by default, and have the internal cache
expire after a set time or clear itself on every read.</p>
</li><li>
<p>&#39;Safe mode&#39; is never used. Making it an option for classes or
specific updates would be...well...safer.</p>
</li><li>
<p>There&#39;s no support yet for deleting records, apart from driver calls on
the class&#39;s collection. Somebody might want to someday.</p>
</li><li>
<p>Index creation is currently left as an exercise to be performed
out-of-band. I do believe a proper persistence framework, even a
transparent one, should have some facility for it.</p>
</li><li>
<p>Likewise, there&#39;s no way yet to set interesting collection options
(capped collections, etc.) except to make the
<strong>Mongo::Collection</strong> object separately and hand it to the
class.</p>
</li><li>
<p>For that matter, capped collections haven&#39;t been tested at all and
might operate weirdly if properties are continually being set on them.</p>
</li><li>
<p>I have only begun optimizing for code beauty, and have not optimized at all
yet for performance. Mongo is fast. I make no guarantees that my
<em>code</em> is fast at this time.</p>
</li><li>
<p>I haven&#39;t tested it at all in Windows. Witness my regret. (Wait, there
isn&#39;t any.)</p>
</li><li>
<p>This library isn&#39;t thread-safe yet. (Which is to say: I haven&#39;t
tried to confirm one way or the other, but I&#39;d be shocked if it was.)</p>
</li><li>
<p>There&#39;s no support yet for ActiveModel or similar validations, et
cetera. It&#39;s on my list to create an extension system, with Rails 3 and
ActiveModel support being the first use case. Right now this is more of a
Sinatra sort of data thingy than a Rails data thingy.</p>
</li></ul>

<h2 id="label-Resources">Resources</h2>

<p>We have the usual array of stuff for your learning pleasure…</p>
<ul><li>
<p><strong>Home page:</strong> <a
href="http://github.com/SFEley/candy">github.com/SFEley/candy</a></p>
</li><li>
<p><strong>Documentation:</strong> <a
href="http://rdoc.info/projects/SFEley/candy">rdoc.info/projects/SFEley/candy</a></p>
</li><li>
<p><strong>Report issues:</strong> <a
href="http://github.com/SFEley/candy/issues">github.com/SFEley/candy/issues</a></p>
</li><li>
<p><strong>Discussion list:</strong> <a
href="http://groups.google.com/group/candy-users">groups.google.com/group/candy-users</a></p>
</li></ul>

<h2 id="label-Contributing">Contributing</h2>

<p>At this early stage, one of the best things you could do is just to tell me
that you have an interest in using this thing. Join the <a
href="http://groups.google.com/group/candy-users">discussion list</a> and
let us know what you think.</p>

<p>Beyond that, report issues, please. If you want to fork it and add
features, fabulous. Send me a pull request.</p>

<p>Oh, and if you like science fiction stories, check out my podcast <a
href="http://escapepod.org">Escape Pod</a>. End of plug.</p>

<h2 id="label-License">License</h2>

<p>This project is licensed under the <a
href="http://github.com/SFEley/candy/blob/master/LICENSE.markdown">Don’t Be
a Dick License</a>, version 0.1, and is copyright 2010 by Stephen Eley. See
the <a
href="http://github.com/SFEley/candy/blob/master/LICENSE.markdown">LICENSE.markdown</a>
file for elaboration on not being a dick. (But you probably already know.)</p>
</div></div>

    <div id="footer">
  Generated on Fri May  1 17:45:35 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.1).
</div>

  </body>
</html>